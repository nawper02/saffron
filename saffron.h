/* saffron.h
 * Saffron is an stb-style graphics engine library.
 *
 * It is designed to render 3d enviornments on
 * embedded devices to virtual camera streams.
 *
 * The purpose of this is to provide an on-device frontend
 * for Orbweaver so that video feeds and mavlink messages
 * do not need to be sent over the network.
 *
 * This also allows it to be used in a video-core module,
 * making it very easy to get video frames generated by
 * Saffron into the video pipeline.
 */

/* SF_TODO
 * 1. Finish primative drawing functions
 * 2. Render text (front a font file of some kind)
 * 3. 3D prep - coordinate systems, transformations 
 *    - support FLU/FRD/NED cleanly/easily
 * 4. Render a 3d file format
 * 5. Create a custom 3d file format, maybe general
 *    as like a 'scene' file (coordinate system, units, global pos?)
 * 6. Lighting
 * 7. Textures
 * 8. ....
 */


/* SF_HEADER */
#ifndef SAFFRON_H
#define SAFFRON_H

#include <ctype.h>
#include <stddef.h>
#ifdef __cplusplus
extern "C" {
#endif

/* INCLUDES */
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

/* SF_TYPES */
typedef uint32_t sf_packed_color_t;
typedef struct { uint8_t  r, g, b, a; } sf_unpacked_color_t;
typedef struct { uint16_t x, y;       } sf_svec2_t;
typedef struct { uint16_t x, y, z;    } sf_svec3_t;
typedef struct {
    int w;
    int h;
    int buffer_size;
    sf_packed_color_t *buffer;
} sf_ctx_t;

/* SF_FUNCTIONS */
void sf_init    (sf_ctx_t *ctx, int w, int h);
void sf_destroy (sf_ctx_t *ctx);
void sf_fill    (sf_ctx_t *ctx, sf_packed_color_t c);
void sf_pixel   (sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t p);
void sf_line    (sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t o,  sf_svec2_t f, int thick);
void sf_rect    (sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t tl, sf_svec2_t tr, uint16_t w, uint16_t h);
void sf_tri     (sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t p1, sf_svec2_t p2, sf_svec2_t p3);
void sf_put_text(sf_ctx_t *ctx, const char *text, sf_svec2_t p, sf_packed_color_t c, int scale);

/* SF_IMPLEMENTATION_HELPERS */
uint32_t _sf_vec_to_index   (sf_ctx_t *ctx, sf_svec2_t v);

/* SF_UTILITIES */
sf_packed_color_t sf_pack_color(sf_unpacked_color_t);

/* SF_DEFINES */
#define SF_COLOR_RED   ((sf_packed_color_t)0xFFFF0000)
#define SF_COLOR_GREEN ((sf_packed_color_t)0xFF00FF00)
#define SF_COLOR_BLUE  ((sf_packed_color_t)0xFF0000FF)
#define SF_COLOR_BLACK ((sf_packed_color_t)0xFF000000)
#define SF_COLOR_WHITE ((sf_packed_color_t)0xFFFFFFFF)

#ifdef __cplusplus
}
#endif
#endif /* SAFFRON_H */

/* SF_IMPLEMENTATION */
#ifdef SAFFRON_IMPLEMENTATION

/* SF_FUNCTIONS */
void sf_init(sf_ctx_t* ctx, int w, int h) {
  ctx->w             = w;
  ctx->h             = h;
  ctx->buffer_size   = w * h;
  ctx->buffer        = (sf_packed_color_t*)malloc(w*h*sizeof(sf_packed_color_t));
}

void sf_destroy(sf_ctx_t *ctx) {
  free(ctx->buffer);
  ctx->buffer      = NULL;
  ctx->buffer_size = 0;
  ctx->w           = 0;
  ctx->h           = 0;
}

void sf_fill(sf_ctx_t *ctx, sf_packed_color_t c) {
   for(size_t i = 0; i < ctx->buffer_size; ++i) { ctx->buffer[i] = c; }
}

void sf_pixel(sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t p) {
  if (p.x > ctx->w || p.y > ctx->h) return;
  ctx->buffer[_sf_vec_to_index(ctx, p)] = c;
}

/* SF_IMPLEMENTATION_HELPERS */
uint32_t _sf_vec_to_index(sf_ctx_t *ctx, sf_svec2_t v) {
  return v.y * ctx->w + v.x;
}

/* SF_UTILITIES */
sf_packed_color_t sf_pack_color(sf_unpacked_color_t c) {
  return ((uint32_t)c.a << 24) | 
         ((uint32_t)c.r << 16) | 
         ((uint32_t)c.g << 8 ) |
          (uint32_t)c.b;
}

#endif /* SAFFRON_IMPLEMENTATION */
