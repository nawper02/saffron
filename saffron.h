/* saffron.h
 * Saffron is an stb-style graphics engine library.
 *
 * It is designed to render 3d enviornments on
 * embedded devices to virtual camera streams.
 *
 * The purpose of this is to provide an on-device frontend
 * for Orbweaver so that video feeds and mavlink messages
 * do not need to be sent over the network.
 *
 * This also allows it to be used in a video-core module,
 * making it very easy to get video frames generated by
 * Saffron into the video pipeline.
 */

/* SF_TODO
 *  Render text (front a font file of some kind)
 *  3D prep - coordinate systems, transformations 
 *  - support FLU/FRD/NED cleanly/easily
 *  Render a 3d file format
 *  Create a custom 3d file format, maybe general
 *  as like a 'scene' file (coordinate system, units, global pos?)
 *  Lighting
 *  Textures
 *  ....
 *  Optimize. Primatives are not at all fast.
 */


/* SF_HEADER */
#ifndef SAFFRON_H
#define SAFFRON_H

#ifdef __cplusplus
extern "C" {
#endif

/* SF_INCLUDES */
#include <ctype.h>
#include <stddef.h>
#include <sys/types.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>

/* SF_DEFINES */
#define SF_ARENA_SIZE 10485760
#define SF_MAX_OBJS   10

/* SF_TYPES */
typedef void (*sf_log_fn)(const char* message, void* userdata);
typedef enum {
    SF_LOG_DEBUG,
    SF_LOG_INFO,
    SF_LOG_WARN,
    SF_LOG_ERROR
} sf_log_level_t;

typedef uint32_t sf_packed_color_t;
typedef struct { uint8_t  r, g, b, a; } sf_unpacked_color_t;

typedef struct { uint16_t x, y;       } sf_svec2_t;
typedef struct { uint16_t x, y, z;    } sf_svec3_t;
typedef struct { float    x, y, z;    } sf_fvec3_t;
typedef struct { int      x, y, z;    } sf_ivec3_t;

typedef struct {
  sf_fvec3_t *v;
  sf_ivec3_t *f;
  int32_t v_cnt;
  int32_t f_cnt;
} sf_obj_t;

typedef struct {
  size_t size;
  size_t offset;
  uint8_t *buffer;
} sf_arena_t;
typedef struct {
  int w;
  int h;
  int buffer_size;
  sf_packed_color_t *buffer;

  sf_arena_t arena;
  int        arena_size;

  sf_obj_t *objs;
  int32_t   obj_count;

  sf_log_fn      log_cb;
  void*          log_user;
  sf_log_level_t log_min;
} sf_ctx_t;

/* SF_CORE_FUNCTIONS */
void       sf_init           (sf_ctx_t *ctx, int w, int h);
void       sf_destroy        (sf_ctx_t *ctx);
sf_arena_t sf_arena_init     (size_t size);
void*      sf_arena_alloc    (sf_arena_t *arena, size_t size);
void       sf_set_logger     (sf_ctx_t *ctx, sf_log_fn log_cb, void* userdata);
void       sf_logger_console (const char* message, void* userdata);
void       sf_log            (sf_ctx_t *ctx, sf_log_level_t level, const char* fmt, ...);
sf_obj_t*  sf_load_obj       (sf_ctx_t *ctx, const char *filename);

/* SF_DRAWING_FUNCTIONS */
void sf_fill     (sf_ctx_t *ctx, sf_packed_color_t c);
void sf_pixel    (sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0);
void sf_line     (sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, sf_svec2_t v1);
void sf_rect     (sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, sf_svec2_t v1);
void sf_tri      (sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, sf_svec2_t v1, sf_svec2_t v2);
void sf_put_text (sf_ctx_t *ctx, const char *text, sf_svec2_t p, sf_packed_color_t c, int scale);

/* SF_IMPLEMENTATION_HELPERS */
uint32_t _sf_vec_to_index  (sf_ctx_t *ctx, sf_svec2_t v);
void     _sf_swap_svec2    (sf_svec2_t *v0, sf_svec2_t *v1);
void     _sf_interpolate_x (sf_svec2_t  v0, sf_svec2_t v1, uint16_t *xs);
void     _sf_interpolate_y (sf_svec2_t  v0, sf_svec2_t v1, uint16_t *ys);

/* SF_UTILITIES */
sf_packed_color_t sf_pack_color(sf_unpacked_color_t);

/* SF_DEFINES */
#define SF_COLOR_RED   ((sf_packed_color_t)0xFFFF0000)
#define SF_COLOR_GREEN ((sf_packed_color_t)0xFF00FF00)
#define SF_COLOR_BLUE  ((sf_packed_color_t)0xFF0000FF)
#define SF_COLOR_BLACK ((sf_packed_color_t)0xFF000000)
#define SF_COLOR_WHITE ((sf_packed_color_t)0xFFFFFFFF)

#ifdef __cplusplus
}
#endif
#endif /* SAFFRON_H */

/* SF_IMPLEMENTATION */
#ifdef SAFFRON_IMPLEMENTATION

/* SF_CORE_FUNCTIONS */
void sf_init(sf_ctx_t* ctx, int w, int h) {
  ctx->w             = w;
  ctx->h             = h;
  ctx->buffer_size   = w * h;
  ctx->buffer        = (sf_packed_color_t*)malloc(w*h*sizeof(sf_packed_color_t));
  ctx->arena         = sf_arena_init(SF_ARENA_SIZE);
  ctx->log_cb        = sf_logger_console;
  ctx->log_user      = NULL;
  ctx->log_min       = SF_LOG_INFO;
  ctx->objs          = sf_arena_alloc(&ctx->arena, SF_MAX_OBJS * sizeof(sf_obj_t));
  ctx->obj_count     = 0;
  sf_log(ctx, SF_LOG_INFO, "sf_init\n"
                           "          buffer : %dx%d\n"
                           "          memory : %d\n"
                           "          mxobjs : %d\n", 
                           ctx->w, ctx->h, SF_ARENA_SIZE, SF_MAX_OBJS);
}

void sf_destroy(sf_ctx_t *ctx) {
  free(ctx->buffer);
  free(ctx->arena.buffer);
  ctx->arena.offset = 0;
  ctx->buffer       = NULL;
  ctx->buffer_size  = 0;
  ctx->w            = 0;
  ctx->h            = 0;
  sf_log(ctx, SF_LOG_INFO, "sf_destroy\n"
                           "          buffer : %dx%d\n"
                           "          memory : %d\n"
                           "          mxobjs : %d\n", 
                           ctx->w, ctx->h, SF_ARENA_SIZE, SF_MAX_OBJS);
}

sf_arena_t sf_arena_init(size_t size) {
  sf_arena_t arena;
  arena.size = size;
  arena.offset = 0;
  arena.buffer = malloc(size);
  return arena;
}

void* sf_arena_alloc(sf_arena_t *arena, size_t size) {
  if (arena->offset + size > arena->size) return NULL;
  void *ptr = &arena->buffer[arena->offset];
  arena->offset += size;
  return ptr;
}

void sf_set_logger(sf_ctx_t *ctx, sf_log_fn callback, void* userdata) {
  ctx->log_cb = callback;
  ctx->log_user = userdata;
}

void sf_logger_console(const char* message, void* userdata) {
  fprintf(stdout, "[Saffron] %s", message);
}

void sf_log(sf_ctx_t *ctx, sf_log_level_t level, const char* fmt, ...) {
  if (!ctx->log_cb || level < ctx->log_min) return;

  char buffer[512];
  va_list args;
  va_start(args, fmt);
  vsnprintf(buffer, sizeof(buffer), fmt, args);
  va_end(args);

  ctx->log_cb(buffer, ctx->log_user);
}

sf_obj_t* sf_load_obj(sf_ctx_t *ctx, const char *filename) {
  if (ctx->obj_count >= SF_MAX_OBJS) {
    sf_log(ctx, SF_LOG_ERROR, "sf_load_obj failed: max objects (%d) reached\n", SF_MAX_OBJS);
    return NULL;
  }

  FILE *f = fopen(filename, "r");
  if (!f) {
    sf_log(ctx, SF_LOG_ERROR, "sf_load_obj failed: could not open %s\n", filename);
    return NULL;
  }

  int32_t v_cnt = 0, f_cnt = 0; char line[256];
  while (fgets(line, sizeof(line), f)) {
    if      (line[0] == 'v' && line[1] == ' ') v_cnt++;
    else if (line[0] == 'f' && line[1] == ' ') f_cnt++;
  }

  sf_obj_t *obj = &ctx->objs[ctx->obj_count++];
  obj->f_cnt = f_cnt; obj->v_cnt = v_cnt;
  obj->v = sf_arena_alloc(&ctx->arena, v_cnt * sizeof(sf_fvec3_t));
  obj->f = sf_arena_alloc(&ctx->arena, f_cnt * sizeof(sf_ivec3_t));

  if (!obj->v || !obj->f) {
    sf_log(ctx, SF_LOG_ERROR, "sf_load_obj failed: out of arena memory for %s\n", filename);
    fclose(f);
    return NULL;
  }

  sf_log(ctx, SF_LOG_INFO, "sf_load_obj\n"
                             "          file   : %s\n"
                             "          verts  : %d\n"
                             "          faces  : %d\n"
                             "          obj_id : %d\n", 
                             filename, v_cnt, f_cnt, ctx->obj_count - 1);

  rewind(f);
  int v_idx = 0, f_idx = 0;
  while (fgets(line, sizeof(line), f)) {
    if (line[0] == 'v' && line[1] == ' ') {
      sscanf(line, "v %f %f %f", &obj->v[v_idx].x, &obj->v[v_idx].y, &obj->v[v_idx].z);
      v_idx++;
    }
    else if (line[0] == 'f' && line[1] == ' ') {
      sscanf(line, "f %d %d %d", &obj->f[f_idx].x, &obj->f[f_idx].y, &obj->f[f_idx].z);
      obj->f[f_idx].x -= 1; obj->f[f_idx].y -= 1; obj->f[f_idx].z -= 1;
      f_idx++;
    }
  }

  fclose(f);
  return obj;
}

/* SF_DRAWING_FUNCTIONS */

void sf_fill(sf_ctx_t *ctx, sf_packed_color_t c) {
 for(size_t i = 0; i < ctx->buffer_size; ++i) { ctx->buffer[i] = c; }
}

void sf_pixel(sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0) {
  if (v0.x >= ctx->w || v0.y >= ctx->h) return;
  ctx->buffer[_sf_vec_to_index(ctx, v0)] = c;
}

void sf_line(sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, sf_svec2_t v1) {
  if (v1.y - v0.y > v1.x - v0.x) {
    uint16_t x01[v1.y-v0.y+1];
    _sf_interpolate_x(v0, v1, x01);
    for (uint16_t y = v0.y; y <= v1.y; ++y) {
      sf_pixel(ctx, c, (sf_svec2_t){x01[y-v0.y],y});
    }
  }
  else {
    uint16_t y01[v1.x-v0.x+1];
    _sf_interpolate_y(v0, v1, y01);
    for (uint16_t x = v0.x; x <= v1.x; ++x) {
      sf_pixel(ctx, c, (sf_svec2_t){x,y01[x-v0.x]});
    }
  }
}

void sf_rect(sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, sf_svec2_t v1) {
  uint16_t l = (v0.x < v1.x) ? v0.x : v1.x;
  uint16_t r = (v0.x > v1.x) ? v0.x : v1.x;
  uint16_t t = (v0.y < v1.y) ? v0.y : v1.y;
  uint16_t b = (v0.y > v1.y) ? v0.y : v1.y;
  for (uint16_t y = t; y <= b; ++y) {
    for (uint16_t x = l; x <= r; ++x) {
      sf_pixel(ctx, c, (sf_svec2_t){x,y});
    }
  }
}

void sf_tri(sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, sf_svec2_t v1, sf_svec2_t v2) {
  if (v1.y < v0.y) _sf_swap_svec2(&v0, &v1);
  if (v2.y < v0.y) _sf_swap_svec2(&v2, &v0);
  if (v2.y < v1.y) _sf_swap_svec2(&v2, &v1);
  uint16_t h = v2.y - v0.y + 1;
  uint16_t x02[h], x012[h];
  _sf_interpolate_x(v0, v1, x012);
  _sf_interpolate_x(v1, v2, &x012[v1.y - v0.y]);
  _sf_interpolate_x(v0, v2, x02);
  uint16_t mid_idx = v1.y - v0.y;
  uint16_t *xl = (x02[mid_idx] < x012[mid_idx]) ? x02  : x012;
  uint16_t *xr = (x02[mid_idx] < x012[mid_idx]) ? x012 : x02;
  for (uint16_t y = v0.y; y <= v2.y; ++y) {
    for (uint16_t x = xl[y - v0.y]; x <= xr[y - v0.y]; ++x) {
      sf_pixel(ctx, c, (sf_svec2_t){x, y});
    }
  }
}

/* SF_IMPLEMENTATION_HELPERS */
uint32_t _sf_vec_to_index(sf_ctx_t *ctx, sf_svec2_t v) {
  return v.y * ctx->w + v.x;
}

void _sf_swap_svec2(sf_svec2_t *v0, sf_svec2_t *v1) {
  sf_svec2_t t = *v0; *v0 = *v1; *v1 = t;
}

void _sf_interpolate_x(sf_svec2_t v0, sf_svec2_t v1, uint16_t *xs) {
  if (v0.y == v1.y) {
    xs[0] = v0.x;
    return;
  }
  for (uint16_t y = v0.y; y <= v1.y; ++y) {
    xs[y - v0.y] = (y - v0.y) * (v1.x - v0.x) / (v1.y - v0.y) + v0.x;
  }
}

void _sf_interpolate_y(sf_svec2_t v0, sf_svec2_t v1, uint16_t *ys) {
  if (v0.x == v1.x) {
    ys[0] = v0.y;
    return;
  }
  for (uint16_t x = v0.x; x <= v1.x; ++x) {
    ys[x - v0.x] = (x - v0.x) * (v1.y - v0.y) / (v1.x - v0.x) + v0.y;
  }
}

/* SF_UTILITIES */
sf_packed_color_t sf_pack_color(sf_unpacked_color_t c) {
  return ((uint32_t)c.a << 24) | 
         ((uint32_t)c.r << 16) | 
         ((uint32_t)c.g << 8 ) |
          (uint32_t)c.b;
}

#endif /* SAFFRON_IMPLEMENTATION */
