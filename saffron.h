/* saffron.h
 * Saffron is an stb-style graphics engine library.
 *
 * It is designed to render 3d enviornments on
 * embedded devices to virtual camera streams.
 *
 * The purpose of this is to provide an on-device frontend
 * for Orbweaver so that video feeds and mavlink messages
 * do not need to be sent over the network.
 *
 * This also allows it to be used in a video-core module,
 * making it very easy to get video frames generated by
 * Saffron into the video pipeline.
 */

/* SF_TODO
 * 1. Finish primative drawing functions
 * 2. Render text (front a font file of some kind)
 * 3. 3D prep - coordinate systems, transformations 
 *    - support FLU/FRD/NED cleanly/easily
 * 4. Render a 3d file format
 * 5. Create a custom 3d file format, maybe general
 *    as like a 'scene' file (coordinate system, units, global pos?)
 * 6. Lighting
 * 7. Textures
 * 8. ....
 */


/* SF_HEADER */
#ifndef SAFFRON_H
#define SAFFRON_H

#include <ctype.h>
#include <stddef.h>
#include <sys/types.h>
#ifdef __cplusplus
extern "C" {
#endif

/* INCLUDES */
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>

/* SF_TYPES */
typedef uint32_t sf_packed_color_t;
typedef struct { uint8_t  r, g, b, a; } sf_unpacked_color_t;
typedef struct { uint16_t x, y;       } sf_svec2_t;
typedef struct { uint16_t x, y, z;    } sf_svec3_t;
typedef struct {
    int w;
    int h;
    int buffer_size;
    sf_packed_color_t *buffer;
} sf_ctx_t;

/* SF_FUNCTIONS */
void sf_init    (sf_ctx_t *ctx, int w, int h);
void sf_destroy (sf_ctx_t *ctx);
void sf_fill    (sf_ctx_t *ctx, sf_packed_color_t c);
void sf_pixel   (sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0);
void sf_line    (sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, sf_svec2_t v1);
void sf_rect    (sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, uint16_t w, uint16_t h);
void sf_tri     (sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, sf_svec2_t v1, sf_svec2_t v2);
void sf_put_text(sf_ctx_t *ctx, const char *text, sf_svec2_t p, sf_packed_color_t c, int scale);

/* SF_IMPLEMENTATION_HELPERS */
uint32_t _sf_vec_to_index  (sf_ctx_t *ctx, sf_svec2_t v);
void     _sf_swap_svec2    (sf_svec2_t *v0, sf_svec2_t *v1);
void     _sf_interpolate_x (sf_svec2_t  v0, sf_svec2_t v1, uint16_t *xs);
void     _sf_interpolate_y (sf_svec2_t  v0, sf_svec2_t v1, uint16_t *ys);

/* SF_UTILITIES */
sf_packed_color_t sf_pack_color(sf_unpacked_color_t);

/* SF_DEFINES */
#define SF_COLOR_RED   ((sf_packed_color_t)0xFFFF0000)
#define SF_COLOR_GREEN ((sf_packed_color_t)0xFF00FF00)
#define SF_COLOR_BLUE  ((sf_packed_color_t)0xFF0000FF)
#define SF_COLOR_BLACK ((sf_packed_color_t)0xFF000000)
#define SF_COLOR_WHITE ((sf_packed_color_t)0xFFFFFFFF)

#ifdef __cplusplus
}
#endif
#endif /* SAFFRON_H */

/* SF_IMPLEMENTATION */
#ifdef SAFFRON_IMPLEMENTATION

/* SF_FUNCTIONS */
void sf_init(sf_ctx_t* ctx, int w, int h) {
  ctx->w             = w;
  ctx->h             = h;
  ctx->buffer_size   = w * h;
  ctx->buffer        = (sf_packed_color_t*)malloc(w*h*sizeof(sf_packed_color_t));
}

void sf_destroy(sf_ctx_t *ctx) {
  free(ctx->buffer);
  ctx->buffer      = NULL;
  ctx->buffer_size = 0;
  ctx->w           = 0;
  ctx->h           = 0;
}

void sf_fill(sf_ctx_t *ctx, sf_packed_color_t c) {
   for(size_t i = 0; i < ctx->buffer_size; ++i) { ctx->buffer[i] = c; }
}

void sf_pixel(sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0) {
  if (v0.x > ctx->w || v0.y > ctx->h) return;
  ctx->buffer[_sf_vec_to_index(ctx, v0)] = c;
}

void sf_line(sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, sf_svec2_t v1) {
  if (v1.y - v0.y > v1.x - v0.x) {
    uint16_t x01[v1.y-v0.y+1];
    _sf_interpolate_x(v0, v1, x01);
    for (uint16_t y = v0.y; y <= v1.y; ++y) {
      sf_pixel(ctx, c, (sf_svec2_t){x01[y-v0.y],y});
    }
  }
  else {
    uint16_t y01[v1.x-v0.x+1];
    _sf_interpolate_y(v0, v1, y01);
    for (uint16_t x = v0.x; x <= v1.x; ++x) {
      sf_pixel(ctx, c, (sf_svec2_t){x,y01[x-v0.x]});
    }
  }
}

void sf_tri(sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, sf_svec2_t v1, sf_svec2_t v2) {
  // Sort corners by y
  if (v1.y < v0.y) _sf_swap_svec2(&v0, &v1);
  if (v2.y < v0.y) _sf_swap_svec2(&v2, &v0);
  if (v2.y < v1.y) _sf_swap_svec2(&v2, &v1);
  // for v0->v1, v1->v2, and v0->v2, find x values for each y value
  // num entries is equal to num y values, so allocate it and pass it in
  uint16_t x01[v1.y-v0.y+1];
  uint16_t x12[v2.y-v1.y+1];
  uint16_t x02[v2.y-v0.y+1];
  _sf_interpolate_x(v0, v1, x01);
  _sf_interpolate_x(v1, v2, x12);
  _sf_interpolate_x(v0, v2, x02);
}

/* SF_IMPLEMENTATION_HELPERS */
uint32_t _sf_vec_to_index(sf_ctx_t *ctx, sf_svec2_t v) {
  return v.y * ctx->w + v.x;
}

void _sf_swap_svec2(sf_svec2_t *v0, sf_svec2_t *v1) {
  sf_svec2_t t = *v0; *v0 = *v1; *v1 = t;
}

void _sf_interpolate_x(sf_svec2_t v0, sf_svec2_t v1, uint16_t *xs) {
  if (v0.y == v1.y) {
    xs[0] = v0.x;
    return;
  }
  for (uint16_t y = v0.y; y <= v1.y; ++y) {
    xs[y - v0.y] = (y - v0.y) * (v1.x - v0.x) / (v1.y - v0.y) + v0.x;
  }
}

void _sf_interpolate_y(sf_svec2_t v0, sf_svec2_t v1, uint16_t *ys) {
  if (v0.x == v1.x) {
    ys[0] = v0.y;
    return;
  }
  for (uint16_t x = v0.x; x <= v1.x; ++x) {
    ys[x - v0.x] = (x - v0.x) * (v1.y - v0.y) / (v1.x - v0.x) + v0.y;
  }
}

/* SF_UTILITIES */
sf_packed_color_t sf_pack_color(sf_unpacked_color_t c) {
  return ((uint32_t)c.a << 24) | 
         ((uint32_t)c.r << 16) | 
         ((uint32_t)c.g << 8 ) |
          (uint32_t)c.b;
}

#endif /* SAFFRON_IMPLEMENTATION */
