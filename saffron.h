/* saffron.h
 * Saffron is an stb-style graphics engine library.
 *
 * It is designed to render 3d enviornments on
 * embedded devices to virtual camera streams.
 *
 * The purpose of this is to provide an on-device frontend
 * for Orbweaver so that video feeds and mavlink messages
 * do not need to be sent over the network.
 *
 * This also allows it to be used in a video-core module,
 * making it very easy to get video frames generated by
 * Saffron into the video pipeline.
 */

/* SF_TODO
 *  Render text (front a font file of some kind)
 *  3D prep - coordinate systems, transformations 
 *  - support FLU/FRD/NED cleanly/easily
 *  Render a 3d file format
 *  Create a custom 3d file format, maybe general
 *  as like a 'scene' file (coordinate system, units, global pos?)
 *  Lighting
 *  Textures
 *  ....
 *  Optimize. Primatives are not at all fast.
 */


/* SF_HEADER */
#ifndef SAFFRON_H
#define SAFFRON_H

#include <ctype.h>
#include <stddef.h>
#include <sys/types.h>
#ifdef __cplusplus
extern "C" {
#endif

/* SF_INCLUDES */
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>

/* SF_DEFINES */
#define SF_ARENA_SIZE 10485760
#define SF_MAX_OBJS   10

/* SF_TYPES */
typedef uint32_t sf_packed_color_t;
typedef struct { uint8_t  r, g, b, a; } sf_unpacked_color_t;
typedef struct { uint16_t x, y;       } sf_svec2_t;
typedef struct { uint16_t x, y, z;    } sf_svec3_t;
typedef struct { float    x, y, z;    } sf_fvec3_t;
typedef struct { int      x, y, z;    } sf_ivec3_t;
typedef struct {
  sf_fvec3_t *v;
  sf_ivec3_t *f;
  int32_t v_count;
  int32_t f_count;
} sf_obj_t;
typedef struct {
    size_t size;
    size_t offset;
    uint8_t *buffer;
} sf_arena_t;
typedef struct {
    int w;
    int h;
    int buffer_size;
    sf_packed_color_t *buffer;
    int arena_size;
    sf_arena_t arena;
    sf_obj_t *objs;
    int32_t   obj_count;
} sf_ctx_t;

/* SF_CORE_FUNCTIONS */
void       sf_init    (sf_ctx_t *ctx, int w, int h);
void       sf_destroy (sf_ctx_t *ctx);
sf_arena_t sf_arena_init(size_t size);
void*      sf_arena_alloc(sf_arena_t *arena, size_t size);
sf_obj_t*  sf_load_obj(sf_ctx_t *ctx, const char *filename);

/* SF_DRAWING_FUNCTIONS */
void sf_fill    (sf_ctx_t *ctx, sf_packed_color_t c);
void sf_pixel   (sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0);
void sf_line    (sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, sf_svec2_t v1);
void sf_rect    (sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, sf_svec2_t v1);
void sf_tri     (sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, sf_svec2_t v1, sf_svec2_t v2);
void sf_put_text(sf_ctx_t *ctx, const char *text, sf_svec2_t p, sf_packed_color_t c, int scale);

/* SF_IMPLEMENTATION_HELPERS */
uint32_t _sf_vec_to_index  (sf_ctx_t *ctx, sf_svec2_t v);
void     _sf_swap_svec2    (sf_svec2_t *v0, sf_svec2_t *v1);
void     _sf_interpolate_x (sf_svec2_t  v0, sf_svec2_t v1, uint16_t *xs);
void     _sf_interpolate_y (sf_svec2_t  v0, sf_svec2_t v1, uint16_t *ys);

/* SF_UTILITIES */
sf_packed_color_t sf_pack_color(sf_unpacked_color_t);

/* SF_DEFINES */
#define SF_COLOR_RED   ((sf_packed_color_t)0xFFFF0000)
#define SF_COLOR_GREEN ((sf_packed_color_t)0xFF00FF00)
#define SF_COLOR_BLUE  ((sf_packed_color_t)0xFF0000FF)
#define SF_COLOR_BLACK ((sf_packed_color_t)0xFF000000)
#define SF_COLOR_WHITE ((sf_packed_color_t)0xFFFFFFFF)

#ifdef __cplusplus
}
#endif
#endif /* SAFFRON_H */

/* SF_IMPLEMENTATION */
#ifdef SAFFRON_IMPLEMENTATION

/* SF_CORE_FUNCTIONS */
void sf_init(sf_ctx_t* ctx, int w, int h) {
  ctx->w             = w;
  ctx->h             = h;
  ctx->buffer_size   = w * h;
  ctx->buffer        = (sf_packed_color_t*)malloc(w*h*sizeof(sf_packed_color_t));
  ctx->arena         = sf_arena_init(SF_ARENA_SIZE);
  ctx->objs          = sf_arena_alloc(&ctx->arena, SF_MAX_OBJS * sizeof(sf_obj_t));
  ctx->obj_count     = 0;
}

void sf_destroy(sf_ctx_t *ctx) {
  free(ctx->buffer);
  free(ctx->arena.buffer);
  ctx->arena.offset = 0;
  ctx->buffer       = NULL;
  ctx->buffer_size  = 0;
  ctx->w            = 0;
  ctx->h            = 0;
}

sf_arena_t sf_arena_init(size_t size) {
    sf_arena_t arena;
    arena.size = size;
    arena.offset = 0;
    arena.buffer = malloc(size);
    return arena;
}

void* sf_arena_alloc(sf_arena_t *arena, size_t size) {
    if (arena->offset + size > arena->size) return NULL;
    void *ptr = &arena->buffer[arena->offset];
    arena->offset += size;
    return ptr;
}

sf_obj_t* sf_load_obj(sf_ctx_t *ctx, const char *filename) {

}

/* SF_DRAWING_FUNCTIONS */

void sf_fill(sf_ctx_t *ctx, sf_packed_color_t c) {
   for(size_t i = 0; i < ctx->buffer_size; ++i) { ctx->buffer[i] = c; }
}

void sf_pixel(sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0) {
  if (v0.x >= ctx->w || v0.y >= ctx->h) return;
  ctx->buffer[_sf_vec_to_index(ctx, v0)] = c;
}

void sf_line(sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, sf_svec2_t v1) {
  if (v1.y - v0.y > v1.x - v0.x) {
    uint16_t x01[v1.y-v0.y+1];
    _sf_interpolate_x(v0, v1, x01);
    for (uint16_t y = v0.y; y <= v1.y; ++y) {
      sf_pixel(ctx, c, (sf_svec2_t){x01[y-v0.y],y});
    }
  }
  else {
    uint16_t y01[v1.x-v0.x+1];
    _sf_interpolate_y(v0, v1, y01);
    for (uint16_t x = v0.x; x <= v1.x; ++x) {
      sf_pixel(ctx, c, (sf_svec2_t){x,y01[x-v0.x]});
    }
  }
}

void sf_rect(sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, sf_svec2_t v1) {
  uint16_t l = (v0.x < v1.x) ? v0.x : v1.x;
  uint16_t r = (v0.x > v1.x) ? v0.x : v1.x;
  uint16_t t = (v0.y < v1.y) ? v0.y : v1.y;
  uint16_t b = (v0.y > v1.y) ? v0.y : v1.y;
  for (uint16_t y = t; y <= b; ++y) {
    for (uint16_t x = l; x <= r; ++x) {
      sf_pixel(ctx, c, (sf_svec2_t){x,y});
    }
  }
}

void sf_tri(sf_ctx_t *ctx, sf_packed_color_t c, sf_svec2_t v0, sf_svec2_t v1, sf_svec2_t v2) {
  if (v1.y < v0.y) _sf_swap_svec2(&v0, &v1);
  if (v2.y < v0.y) _sf_swap_svec2(&v2, &v0);
  if (v2.y < v1.y) _sf_swap_svec2(&v2, &v1);
  uint16_t h = v2.y - v0.y + 1;
  uint16_t x02[h], x012[h];
  _sf_interpolate_x(v0, v1, x012);
  _sf_interpolate_x(v1, v2, &x012[v1.y - v0.y]);
  _sf_interpolate_x(v0, v2, x02);
  uint16_t mid_idx = v1.y - v0.y;
  uint16_t *xl = (x02[mid_idx] < x012[mid_idx]) ? x02  : x012;
  uint16_t *xr = (x02[mid_idx] < x012[mid_idx]) ? x012 : x02;
  for (uint16_t y = v0.y; y <= v2.y; ++y) {
    for (uint16_t x = xl[y - v0.y]; x <= xr[y - v0.y]; ++x) {
      sf_pixel(ctx, c, (sf_svec2_t){x, y});
    }
  }
}

/* SF_IMPLEMENTATION_HELPERS */
uint32_t _sf_vec_to_index(sf_ctx_t *ctx, sf_svec2_t v) {
  return v.y * ctx->w + v.x;
}

void _sf_swap_svec2(sf_svec2_t *v0, sf_svec2_t *v1) {
  sf_svec2_t t = *v0; *v0 = *v1; *v1 = t;
}

void _sf_interpolate_x(sf_svec2_t v0, sf_svec2_t v1, uint16_t *xs) {
  if (v0.y == v1.y) {
    xs[0] = v0.x;
    return;
  }
  for (uint16_t y = v0.y; y <= v1.y; ++y) {
    xs[y - v0.y] = (y - v0.y) * (v1.x - v0.x) / (v1.y - v0.y) + v0.x;
  }
}

void _sf_interpolate_y(sf_svec2_t v0, sf_svec2_t v1, uint16_t *ys) {
  if (v0.x == v1.x) {
    ys[0] = v0.y;
    return;
  }
  for (uint16_t x = v0.x; x <= v1.x; ++x) {
    ys[x - v0.x] = (x - v0.x) * (v1.y - v0.y) / (v1.x - v0.x) + v0.y;
  }
}

/* SF_UTILITIES */
sf_packed_color_t sf_pack_color(sf_unpacked_color_t c) {
  return ((uint32_t)c.a << 24) | 
         ((uint32_t)c.r << 16) | 
         ((uint32_t)c.g << 8 ) |
          (uint32_t)c.b;
}

#endif /* SAFFRON_IMPLEMENTATION */
